// Generated by CoffeeScript 1.6.2
(function() {
  var Segment, get_cluster_val, get_top_TF, get_word_count, segment, summarize,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Segment = require('node-segment').Segment;

  segment = new Segment();

  segment.useDefault();

  get_cluster_val = function(sentence, words) {
    var clustes, data, index, max_value, no_match, size, v, val, w, _i, _j, _k, _len, _len1, _len2, _ref;

    clustes = [
      {
        words: [],
        count: 0
      }
    ];
    index = 0;
    no_match = 0;
    size = 3;
    _ref = sentence.words;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      v = _ref[_i];
      for (_j = 0, _len1 = words.length; _j < _len1; _j++) {
        w = words[_j];
        if (v.w === w) {
          if (no_match >= size) {
            no_match = 0;
            index = index + 1;
            clustes.push({
              words: [],
              count: 0
            });
          }
          data = clustes[index];
          data.count = data.count + 1;
        } else {
          no_match = no_match + 1;
          data = clustes[index];
        }
        data.words.push(v);
      }
    }
    max_value = 0;
    for (_k = 0, _len2 = clustes.length; _k < _len2; _k++) {
      v = clustes[_k];
      val = v.count * v.count / v.words.length;
      if (val > max_value) {
        max_value = val;
      }
    }
    return max_value;
  };

  get_top_TF = function(sentences) {
    var is_in, v, w, word, word_count, _i, _j, _k, _len, _len1, _len2, _ref, _words;

    _words = [];
    for (_i = 0, _len = sentences.length; _i < _len; _i++) {
      v = sentences[_i];
      _ref = v.words;
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        word = _ref[_j];
        word_count = get_word_count(word, sentences);
        if (word_count) {
          is_in = false;
          for (_k = 0, _len2 = _words.length; _k < _len2; _k++) {
            w = _words[_k];
            if (w.word === word_count.word) {
              is_in = true;
              break;
            }
          }
          if (false === is_in) {
            _words.push(word_count);
          }
        }
      }
    }
    return _words.sort(function(a, b) {
      return b.count - a.count;
    });
  };

  get_word_count = function(word, sentences) {
    var count, not_good, txt, v, w, _i, _j, _len, _len1, _ref, _ref1;

    not_good = [8192, 4096, 262144, 2048];
    txt = word.w.toString().trim();
    if (txt.length < 2) {
      return false;
    }
    if (false === /.*[\u4e00-\u9fa5]+.*$/.test(txt) && txt.length <= 2) {
      if (txt.toUpperCase() !== txt) {
        return false;
      }
    }
    if (_ref = word.p, __indexOf.call(not_good, _ref) >= 0) {
      return false;
    }
    count = 0;
    for (_i = 0, _len = sentences.length; _i < _len; _i++) {
      v = sentences[_i];
      _ref1 = v.words;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        w = _ref1[_j];
        if (word.w === w.w) {
          count = count + 1;
        }
      }
    }
    return {
      count: count,
      word: txt
    };
  };

  summarize = function(html) {
    var data, hot_words, k, keyword, pattern, rs, sentences, summarizes, txt, v, v2, v3, word_count, word_line, words, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _len7, _m, _n, _o, _p, _ref, _ref1, _ref2, _ref3;

    txt = html.trim().replace(/<\/p>/g, '\n').replace(/<\/?[^>]*>/g, '').replace(/[ | ]*\n/g, '\n').replace(/\\n\\n/g, '\n').replace(/&nbsp;/ig, '');
    sentences = [];
    _ref = txt.split('\n');
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      v = _ref[_i];
      _ref1 = v.split('。');
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        v = _ref1[_j];
        _ref2 = v.split('. ');
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          v2 = _ref2[_k];
          v2 = v2.trim();
          if (v2 !== '') {
            word_line = v2.toString().trim();
            pattern = new RegExp("[`~#$^&*()|{}''\\[\\]<>~#%lt￥……&*（）&|【】‘”“'、？]");
            rs = [];
            _ref3 = word_line.split('');
            for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
              v3 = _ref3[_l];
              rs.push(v3.replace(pattern, '').toString());
            }
            word_line = rs.join('').toString();
            if (rs.length) {
              if (/.*[\u4e00-\u9fa5]+.*$/.test(word_line)) {
                if (word_line.length < 15) {
                  continue;
                }
              } else if (word_line.length < 30) {
                continue;
              }
              sentences.push({
                sentence: word_line,
                words: segment.doSegment(v2)
              });
            }
          }
        }
      }
    }
    words = [];
    hot_words = get_top_TF(sentences);
    word_count = hot_words.length * .10;
    if (word_count <= 10) {
      word_count = 10;
    }
    for (k = _m = 0, _len4 = hot_words.length; _m < _len4; k = ++_m) {
      v = hot_words[k];
      if (k >= word_count) {
        break;
      }
      words.push(v.word.w);
    }
    data = [];
    for (_n = 0, _len5 = sentences.length; _n < _len5; _n++) {
      v = sentences[_n];
      data.push({
        sentence: v.sentence,
        val: get_cluster_val(v, words)
      });
    }
    data = data.sort(function(a, b) {
      return b.val - a.val;
    });
    summarizes = [];
    for (k = _o = 0, _len6 = data.length; _o < _len6; k = ++_o) {
      v = data[k];
      if (k === 3) {
        break;
      }
      summarizes.push(v.sentence);
    }
    keyword = [];
    for (k = _p = 0, _len7 = hot_words.length; _p < _len7; k = ++_p) {
      v = hot_words[k];
      if (k === 10) {
        break;
      }
      keyword.push(v.word);
    }
    return {
      summarizes: summarizes,
      words: keyword,
      txt: txt
    };
  };

  exports.summarize = summarize;

  return;

}).call(this);
